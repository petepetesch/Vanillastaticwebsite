{"version":3,"file":"searchIndexingBufferedSender.js","sourceRoot":"","sources":["../../src/searchIndexingBufferedSender.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { IndexDocumentsBatch } from \"./indexDocumentsBatch\";\nimport {\n  IndexDocumentsAction,\n  SearchIndexingBufferedSenderOptions,\n  SearchIndexingBufferedSenderUploadDocumentsOptions,\n  SearchIndexingBufferedSenderMergeDocumentsOptions,\n  SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions,\n  SearchIndexingBufferedSenderDeleteDocumentsOptions,\n  SearchIndexingBufferedSenderFlushDocumentsOptions,\n  IndexDocumentsOptions\n} from \"./indexModels\";\nimport { IndexDocumentsResult } from \"./generated/data/models\";\nimport { RestError, OperationOptions } from \"@azure/core-http\";\nimport EventEmitter from \"events\";\nimport { createSpan } from \"./tracing\";\nimport { CanonicalCode } from \"@opentelemetry/api\";\nimport { delay } from \"@azure/core-http\";\nimport { getRandomIntegerInclusive } from \"./serviceUtils\";\n\n/**\n * Index Documents Client\n */\nexport interface IndexDocumentsClient<T> {\n  /**\n   * Perform a set of index modifications (upload, merge, mergeOrUpload, delete)\n   * for the given set of documents.\n   *\n   * @param batch - An array of actions to perform on the index.\n   * @param options - Additional options.\n   */\n  indexDocuments(\n    batch: IndexDocumentsBatch<T>,\n    options: IndexDocumentsOptions\n  ): Promise<IndexDocumentsResult>;\n}\n\n/**\n * Default Batch Size\n */\nexport const DEFAULT_BATCH_SIZE: number = 512;\n/**\n * Default window flush interval\n */\nexport const DEFAULT_FLUSH_WINDOW: number = 60000;\n/**\n * Default number of times to retry.\n */\nexport const DEFAULT_RETRY_COUNT: number = 3;\n/**\n * Default retry delay.\n */\nexport const DEFAULT_RETRY_DELAY: number = 800;\n/**\n * Default Max Delay between retries.\n */\nexport const DEFAULT_MAX_RETRY_DELAY: number = 60000;\n\n/**\n * Class used to perform buffered operations against a search index,\n * including adding, updating, and removing them.\n */\nexport class SearchIndexingBufferedSender<T> {\n  /**\n   * Search Client used to call the underlying IndexBatch operations.\n   */\n  private client: IndexDocumentsClient<T>;\n  /**\n   * Indicates if autoFlush is enabled.\n   */\n  private autoFlush: boolean;\n  /**\n   * Interval between flushes (in milliseconds).\n   */\n  private flushWindowInMs: number;\n  /**\n   * Delay between retries\n   */\n  private throttlingDelayInMs: number;\n  /**\n   * Maximum number of Retries\n   */\n  private maxRetriesPerAction: number;\n  /**\n   * Max Delay between retries\n   */\n  private maxThrottlingDelayInMs: number;\n  /**\n   * Size of the batch.\n   */\n  private initialBatchActionCount: number;\n  /**\n   * Batch object used to complete the service call.\n   */\n  private batchObject: IndexDocumentsBatch<T>;\n  /**\n   * Clean up for the timer\n   */\n  private cleanupTimer?: () => void;\n  /**\n   * Event emitter/publisher used in the Buffered Sender\n   */\n  private readonly emitter = new EventEmitter();\n  /**\n   * Method to retrieve the document key\n   */\n  private documentKeyRetriever: (document: T) => string;\n\n  /**\n   * Creates a new instance of SearchIndexingBufferedSender.\n   *\n   * @param client - Search Client used to call the underlying IndexBatch operations.\n   * @param options - Options to modify auto flush.\n   *\n   */\n  constructor(\n    client: IndexDocumentsClient<T>,\n    documentKeyRetriever: (document: T) => string,\n    options: SearchIndexingBufferedSenderOptions = {}\n  ) {\n    this.client = client;\n    this.documentKeyRetriever = documentKeyRetriever;\n    // General Configuration properties\n    this.autoFlush = options.autoFlush ?? true;\n    this.initialBatchActionCount = options.initialBatchActionCount ?? DEFAULT_BATCH_SIZE;\n    this.flushWindowInMs = options.flushWindowInMs ?? DEFAULT_FLUSH_WINDOW;\n    // Retry specific configuration properties\n    this.throttlingDelayInMs = options.throttlingDelayInMs ?? DEFAULT_FLUSH_WINDOW;\n    this.maxRetriesPerAction = options.maxRetriesPerAction ?? DEFAULT_RETRY_COUNT;\n    this.maxThrottlingDelayInMs = options.maxThrottlingDelayInMs ?? DEFAULT_MAX_RETRY_DELAY;\n\n    this.batchObject = new IndexDocumentsBatch<T>();\n    if (this.autoFlush) {\n      const interval = setInterval(() => this.flush(), this.flushWindowInMs);\n      interval?.unref();\n      this.cleanupTimer = () => {\n        clearInterval(interval);\n      };\n    }\n  }\n\n  /**\n   * Uploads the documents/Adds the documents to the upload queue.\n   *\n   * @param documents - Documents to be uploaded.\n   * @param options - Upload options.\n   */\n  public async uploadDocuments(\n    documents: T[],\n    options: SearchIndexingBufferedSenderUploadDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-uploadDocuments\",\n      options\n    );\n    try {\n      this.batchObject.upload(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"upload\",\n        documents\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Merges the documents/Adds the documents to the merge queue.\n   *\n   * @param documents - Documents to be merged.\n   * @param options - Upload options.\n   */\n  public async mergeDocuments(\n    documents: T[],\n    options: SearchIndexingBufferedSenderMergeDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-mergeDocuments\",\n      options\n    );\n    try {\n      this.batchObject.merge(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"merge\",\n        documents\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Merges/Uploads the documents/Adds the documents to the merge/upload queue.\n   *\n   * @param documents - Documents to be merged/uploaded.\n   * @param options - Upload options.\n   */\n  public async mergeOrUploadDocuments(\n    documents: T[],\n    options: SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-mergeOrUploadDocuments\",\n      options\n    );\n    try {\n      this.batchObject.mergeOrUpload(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"mergeOrUpload\",\n        documents\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes the documents/Adds the documents to the delete queue.\n   *\n   * @param documents - Documents to be deleted.\n   * @param options - Upload options.\n   */\n  public async deleteDocuments(\n    documents: T[],\n    options: SearchIndexingBufferedSenderDeleteDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-deleteDocuments\",\n      options\n    );\n    try {\n      this.batchObject.delete(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"delete\",\n        documents\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Flushes the queue manually.\n   *\n   * @param options - Flush options.\n   */\n  public async flush(\n    options: SearchIndexingBufferedSenderFlushDocumentsOptions = {}\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexingBufferedSender-flush\", options);\n    try {\n      if (this.batchObject.actions.length > 0) {\n        return this.internalFlush(true, updatedOptions);\n      }\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * If using autoFlush: true, call this to cleanup the autoflush timer.\n   */\n  public async dispose(): Promise<void> {\n    if (this.batchObject.actions.length > 0) {\n      await this.internalFlush(true);\n    }\n    if (this.cleanupTimer) {\n      this.cleanupTimer();\n    }\n  }\n\n  /**\n   * Attach Batch Added Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"batchAdded\", listener: (e: { action: string; documents: T[] }) => void): void;\n  /**\n   * Attach Batch Sent Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"beforeDocumentSent\", listener: (e: IndexDocumentsAction<T>) => void): void;\n  /**\n   * Attach Batch Succeeded Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"batchSucceeded\", listener: (e: IndexDocumentsResult) => void): void;\n  /**\n   * Attach Batch Failed Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"batchFailed\", listener: (e: RestError) => void): void;\n  public on(\n    event: \"batchAdded\" | \"beforeDocumentSent\" | \"batchSucceeded\" | \"batchFailed\" | \"batchResizing\",\n    listener: (e: any) => void\n  ): void {\n    this.emitter.on(event, listener);\n  }\n\n  /**\n   * Detach Batch Added Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(event: \"batchAdded\", listener: (e: { action: string; documents: T[] }) => void): void;\n  /**\n   * Detach Batch Sent Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(event: \"beforeDocumentSent\", listener: (e: IndexDocumentsAction<T>) => void): void;\n  /**\n   * Detach Batch Succeeded Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(event: \"batchSucceeded\", listener: (e: IndexDocumentsResult) => void): void;\n  /**\n   * Detach Batch Failed Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(event: \"batchFailed\", listener: (e: RestError) => void): void;\n  public off(\n    event: \"batchAdded\" | \"beforeDocumentSent\" | \"batchSucceeded\" | \"batchFailed\",\n    listener: (e: any) => void\n  ): void {\n    this.emitter.removeListener(event, listener);\n  }\n\n  private isBatchReady(): boolean {\n    return this.batchObject.actions.length >= this.initialBatchActionCount;\n  }\n\n  private async internalFlush(force: boolean, options: OperationOptions = {}): Promise<void> {\n    if (force || (this.autoFlush && this.isBatchReady())) {\n      // Split it\n      const actions: IndexDocumentsAction<T>[] = this.batchObject.actions;\n      this.batchObject = new IndexDocumentsBatch<T>();\n      while (actions.length > 0) {\n        const actionsToSend = actions.splice(0, this.initialBatchActionCount);\n        const { batchToSubmit, submitLater } = this.pruneActions(actionsToSend);\n        actions.unshift(...submitLater);\n        await this.submitDocuments(batchToSubmit, options);\n      }\n    }\n  }\n\n  private pruneActions(\n    batch: IndexDocumentsAction<T>[]\n  ): { batchToSubmit: IndexDocumentsAction<T>[]; submitLater: IndexDocumentsAction<T>[] } {\n    const hashSet: Set<string> = new Set<string>();\n    const resultBatch: IndexDocumentsAction<T>[] = [];\n    const pruned: IndexDocumentsAction<T>[] = [];\n\n    for (const document of batch) {\n      const key = this.documentKeyRetriever((document as unknown) as T);\n      if (hashSet.has(key)) {\n        pruned.push(document);\n      } else {\n        hashSet.add(key);\n        resultBatch.push(document);\n      }\n    }\n    return { batchToSubmit: resultBatch, submitLater: pruned };\n  }\n\n  private async submitDocuments(\n    actionsToSend: IndexDocumentsAction<T>[],\n    options: OperationOptions,\n    retryAttempt: number = 1\n  ): Promise<void> {\n    try {\n      for (const action of actionsToSend) {\n        this.emitter.emit(\"beforeDocumentSent\", action);\n      }\n      const result = await this.client.indexDocuments(\n        new IndexDocumentsBatch<T>(actionsToSend),\n        options\n      );\n      // raise success event\n      this.emitter.emit(\"batchSucceeded\", result);\n    } catch (e) {\n      if (e.statusCode && e.statusCode === 413 && actionsToSend.length > 1) {\n        // Cut the payload size to half\n        const splitActionsArray = [\n          actionsToSend.slice(0, actionsToSend.length / 2),\n          actionsToSend.slice(actionsToSend.length / 2, actionsToSend.length)\n        ];\n        this.initialBatchActionCount = splitActionsArray[0].length; // So, we do not want 413 happening again and again\n        for (const actions of splitActionsArray) {\n          await this.submitDocuments(actions, options);\n        }\n      } else if (this.isRetryAbleError(e) && retryAttempt <= this.maxRetriesPerAction) {\n        // Exponentially increase the delay each time\n        const exponentialDelay = this.throttlingDelayInMs * Math.pow(2, retryAttempt);\n        // Don't let the delay exceed the maximum\n        const clampedExponentialDelay = Math.min(this.maxThrottlingDelayInMs, exponentialDelay);\n        // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n        // that retries across multiple clients don't occur simultaneously.\n        const delayWithJitter =\n          clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);\n        await delay(delayWithJitter);\n        await this.submitDocuments(actionsToSend, options, retryAttempt + 1);\n      } else {\n        this.emitter.emit(\"batchFailed\", e);\n        throw e;\n      }\n    }\n  }\n\n  private isRetryAbleError(e: any): boolean {\n    return e.statusCode && (e.statusCode === 422 || e.statusCode === 409 || e.statusCode === 503);\n  }\n}\n"]}